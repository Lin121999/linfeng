package com.linfeng.lfspring.servlet;import com.linfeng.lfspring.annotation.LFAutowired;import com.linfeng.lfspring.annotation.LFController;import com.linfeng.lfspring.annotation.LFRequestMapping;import com.linfeng.lfspring.annotation.LFService;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.net.URL;import java.util.*;//核心类，最基础的显示了SpringMVC的功能public class LFDispatchServlet extends HttpServlet {    //获取到配置文件    private Properties contextConfig = new Properties();    // 用户存储扫到的类名    private List<String> classNameList = new ArrayList<String>();    //用HashMap当作ioc容器，主要是存储bean和实例化的类    Map<String, Object> iocMap = new HashMap<String, Object>();    Map<String, Method> handlerMapping = new HashMap<String, Method>();    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //7、运行阶段        try {            doDispatch(req, resp);        } catch (Exception e) {            e.printStackTrace();            resp.getWriter().write("500 Exception Detail:\n" + Arrays.toString(e.getStackTrace()));        }    }    private void doDispatch(HttpServletRequest req, HttpServletResponse resp) throws InvocationTargetException, IllegalAccessException {        //        String url = req.getRequestURI();        String contextPath = req.getContextPath();        //将绝对路径替换成相对路径        url = url.replaceAll(contextPath, "").replaceAll("/+", "/");        //没有找到想要的值        if (!this.handlerMapping.containsKey(url)) {            try {                resp.getWriter().write("404 NOT FOUND!!");                return;            } catch (IOException e) {                e.printStackTrace();            }        }        Method method = this.handlerMapping.get(url);        String beanName = toLowerFirstCase(method.getDeclaringClass().getSimpleName());        //利用反射调用这个method.对象只能从ioc容器中拿。        method.invoke(iocMap.get(beanName), req, resp);    }    @Override    public void init(ServletConfig servletConfig) throws ServletException {        //1、加载配置文件        doLoadConfig(servletConfig.getInitParameter("contextConfigLocation"));        //2、扫描相关的类        doScanner(contextConfig.getProperty("scan-package"));        //3、初始化 IOC 容器，将所有相关的类实例保存到 IOC 容器中        doInstance();        //4、依赖注入        doAutowired();        //5、初始化 HandlerMapping        initHandlerMapping();        System.out.println("LFSpring 框架已经初始化完成");    }    //完成SpringMVC的作用    private void initHandlerMapping() {        if (iocMap.isEmpty()) {            return;        }        //将所有ioc容器中已实例化的对象拿出来        for (Map.Entry<String, Object> entry : iocMap.entrySet()) {            //拿到所有的clazz            Class<?> clazz = entry.getValue().getClass();            //判断是不是注解@LFController，是就把所有的public方法            if (!clazz.isAnnotationPresent(LFController.class)) {                continue;            }            String baseUrl = "";            if (clazz.isAnnotationPresent(LFRequestMapping.class)) {                //每个方法都会对应一个url，查看有没@LFRequestMapping。                LFRequestMapping lFRequestMapping = clazz.getAnnotation(LFRequestMapping.class);                baseUrl = lFRequestMapping.value();            }            for (Method method : clazz.getMethods()) {                if (!method.isAnnotationPresent(LFRequestMapping.class)) {                    continue;                }                LFRequestMapping lFRequestMapping = method.getAnnotation(LFRequestMapping.class);                //如果出现多个/,利用正则将其变成一个/                String url = ("/" + baseUrl + "/" + lFRequestMapping.value()).replaceAll("/+", "/");                //将url以及对应的method存入handlerMapping中                handlerMapping.put(url, method);            }        }    }    //实现依赖注入    private void doAutowired() {        if (iocMap.isEmpty()) {            return;        }        for (Map.Entry<String, Object> entry : iocMap.entrySet()) {            Field[] fields = entry.getValue().getClass().getDeclaredFields();            for (Field field : fields) {                if (!field.isAnnotationPresent(LFAutowired.class)) {                    continue;                }                // 获取注解对应的类                LFAutowired lFAutowired = field.getAnnotation(LFAutowired.class);                String beanName = lFAutowired.value().trim();                // 获取 LFAutowired 注解的值                if ("".equals(beanName)) {                    System.out.println("LFAutowired.value() is null");                    beanName = field.getType().getName();                }                // 只要加了注解，都要加载，不管是 private 还是 protect                // 强制加载                field.setAccessible(true);                try {                    field.set(entry.getValue(), iocMap.get(beanName));                    System.out.println("field set {" + entry.getValue() + "} - {" + iocMap.get(beanName) + "}.");                } catch (IllegalAccessException e) {                    e.printStackTrace();                }            }        }    }    //初始化ioc，将所有含有注解的实例化保存到ioc容器中    private void doInstance() {        if (classNameList.isEmpty()) {            return;        }        try {            for (String className : classNameList) {                Class<?> clazz = Class.forName(className);                //判断是否含有@LFController注解，有则利用反射将其实例化并且注入ioc容器中                if (clazz.isAnnotationPresent(LFController.class)) {                    String beanName = toLowerFirstCase(clazz.getSimpleName());                    Object instance = clazz.newInstance();                    // 保存在 ioc 容器                    iocMap.put(beanName, instance);                    System.out.println(beanName + "已经保存到ioc容器中");                    //判断是否含有@LFService注解，有则利用反射将其实例化并且注入ioc容器中                } else if (clazz.isAnnotationPresent(LFService.class)) {                    String beanName = toLowerFirstCase(clazz.getSimpleName());                    // 如果注解包含自定义名称                    LFService lFService = clazz.getAnnotation(LFService.class);                    if (!"".equals(lFService.value())) {                        beanName = lFService.value();                    }                    Object instance = clazz.newInstance();                    iocMap.put(beanName, instance);                    System.out.println(beanName + "已经保存到ioc容器中");                    //针对接口，将接口的类型当作key并注入ioc容器                    for (Class<?> i : clazz.getInterfaces()) {                        //如果接口已经被人占用了                        if (iocMap.containsKey(i.getName())) {                            throw new Exception("The Bean Name Is Exist.");                        }                        iocMap.put(i.getName(), instance);                    }                }            }        } catch (Exception e) {            e.printStackTrace();        }    }   //类的首字母是大写，而bean的id是小写，所以这里将首字母变成小写。    private String toLowerFirstCase(String className) {        char[] charArray = className.toCharArray();        //大写字母的ASCII值+32就可以得到对应小写字母的        charArray[0] += 32;        return String.valueOf(charArray);    }    //扫描从配置文件拿到的scan-package下面的类    private void doScanner(String scanPackage) {        URL resourcePath = this.getClass().getClassLoader().getResource("/" + scanPackage.replaceAll("\\.", "/"));        if (resourcePath == null) {            return;        }        File classPath = new File(resourcePath.getFile());        for (File file : classPath.listFiles()) {            if (file.isDirectory()) {                System.out.println(file.getName() + " 是一个文件夹名，所以继续递归");                //递归寻找.class文件                doScanner(scanPackage + "." + file.getName());            } else {                if (!file.getName().endsWith(".class")) {                    System.out.println(file.getName() + "不是一个.class文件");                    continue;                }                String className = (scanPackage + "." + file.getName()).replace(".class", "");                // 将得到的类除去.class后保存到classNameList中，后面再将其拿到ioc容器中去实例化已经注解类的类                classNameList.add(className);                System.out.println(className + "扫描的类名已经保存到classNameList中");            }        }    }    //加载配置文件，xml文件比较繁琐，这里采用的是propertie配置文件    private void doLoadConfig(String contextConfigLocation) {        //在contextConfigLocation中去寻找        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);        try {            // 保存在内存            contextConfig.load(inputStream);            System.out.println("[INFO-1] property file has been saved in contextConfig.");        } catch (IOException e) {            e.printStackTrace();        } finally {            if (null != inputStream) {                try {                    inputStream.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}